<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <title>Bucket Sort</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lora:ital,wght@0,400;0,700;1,400;1,700&family=Open+Sans+Condensed:ital,wght@0,300;1,300&family=Open+Sans:ital,wght@0,300;0,400;0,700;0,800;1,300;1,400;1,700;1,800&family=Oxygen+Mono&family=Josefin+Sans:ital,wght@0,200;0,600;1,200;1,600&display=swap">
        <link rel="stylesheet" href="assets/css/reset.css">
        <link rel="stylesheet" href="assets/css/highlight.css">
        <link rel="stylesheet" href="assets/css/style.css">
        <link rel="stylesheet" href="assets/css/color.css">
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script async src="https://static.codepen.io/assets/embed/ei.js"></script>
        <script src="assets/js/highlight.js"></script>
        <script src="assets/js/script.js"></script>
    </head>
    <body>
        <div class="container">
            <header>
                <a href="">abrir tudo</a>
                <a href="">fechar tudo</a>
            </header>
            <main>

<h1>Bucket Sort</h1>
<p>Para compreendermos o algoritmo Bucket Sort, vamos primeiro pensar em um exemplo análogo. Imagine um baralho desorganizado.</p>
<p>Ele deve ter 52 cartas divididas em 4 naipes: copas, espadas, ouros e paus (se você não souber o que é cada naipe, veja aqui). Agora imagine que pediram para que você o ordenasse, sendo que as cartas ficariam em ordem crescente e dividas por naipe na seguinte sequência: espadas, ouros, copas e paus.</p>
<p>Se você fosse passar carta por carta, buscando o menor algarismo, os naipes ficariam embaralhados. Se você buscasse o menor naipe, os algarismos ficariam embaralhados.</p>
<blockquote class="question">
<p>Checkpoint</p>
<p>Tendo em vista esse problema dos baralhos, de que outra forma você poderia realizar a ordenação do jogo de cartas?</p>
<details class="answer">
<summary>Gabarito</summary>
<p>Uma metodologia comum seria, primeiramente, agrupar cartas semelhantes. Para isso, sem uma ordem numérica, incialmente, poderíamos percorrer o baralho carta a carta e olhar apenas para seu naipe. De acordo com seu o valor lido, as cartas vão ser inseridas em grupos de cartas com o mesmo naipe, ou “buckets”.</p>
<p>Então, para cada um dos “buckets”, poderíamos ordenar as cartas em ordem crescente, sem se preocupar com os naipes.</p>
<p>Por fim, quando todos os buckets estiverem em ordem crescente, podemos juntá-los conforme conforme solicitado, na ordem espadas, ouros, copas e paus e o baralho estará ordenado.</p>
<figure class="img"><img src="img/baralho.png" alt=""></figure>
</details>
</blockquote>
<h2>Construindo o código</h2>
<p>Tendo em vista como o Bucket Sort opera, vamos agora compreender o modo como ele é implementado. Como esse algoritmo se apropria bastante da utilização de vetores, faremos a implementação em Python, para facilitar a compreensão do código.</p>
<p>Primeiramente, veja o pseudocódigo a seguir e pense se faz sentido de acordo com a explicação anterior do funcionamento do Bucket Sort. Além disso, considerer que será utilizado o Insertion Sort para ordenar cada bucket individualmente.</p>
<pre><code class="language-py">bucketSort(arr[], n)
    Encontrar o elemento máximo e mínimo da array.
    Calcular o intervalo para cada bucket.
	Criar n Buckets vazios (ou listas) com o intervalo calculado.
	Insira os elementos em seus respectivos buckets.
	Ordenar cada bucket individualmente utilizando Insertion Sort.
	Juntar todos os buckets ordenados em um único vetor.
</code></pre>
<blockquote class="warning">
<p>Aviso</p>
<p>Só continue o handout se você entendeu o pseudocódigo!</p>
</blockquote>
<blockquote class="question">
<p>Atividade</p>
<p>Vamos começar pelo primeiro loop do pseudocódigo. Tente implementar em Python a seguinte lógica:</p>
<pre><code class="language-py">bucketSort(arr[], n)
    Encontrar o elemento máximo e mínimo da array.
    
</code></pre>
<details class="answer">
<summary>Gabarito</summary>
<pre><code class="language-py">def bucketSort(arr, noOfBuckets):
    max_ele = max(arr)
    min_ele = min(arr)
</code></pre>
</details>
</blockquote>
<blockquote class="question">
<p>Atividade</p>
<p>Agora vamos para o segundo loop. Tente implementar em Python e adicione ao código do item anterior a lógica abaixo:</p>
<pre><code class="language-py">    Calcular o intervalo para cada bucket.	
</code></pre>
<details class="answer">
<summary>Gabarito</summary>
<pre><code class="language-py">def bucketSort(arr, noOfBuckets):
    max_ele = max(arr)
    min_ele = min(arr)
 
    rnge = (max_ele - min_ele) / noOfBuckets
</code></pre>
</details>
</blockquote>
<blockquote class="question">
<p>Atividade</p>
<p>Agora vamos para o segundo loop. Tente implementar em Python e adicione ao código do item anterior a lógica abaixo:</p>
<pre><code class="language-py">    Criar n Buckets vazios (ou listas) com o intervalo calculado.
	
</code></pre>
<details class="answer">
<summary>Gabarito</summary>
<pre><code class="language-py">def bucketSort(arr, noOfBuckets):
    max_ele = max(arr)
    min_ele = min(arr)
 
    rnge = (max_ele - min_ele) / noOfBuckets
 
    temp = []
 
    for i in range(noOfBuckets):
        temp.append([])
</code></pre>
</details>
</blockquote>
<blockquote class="question">
<p>Atividade</p>
<p>Agora vamos para o segundo loop. Tente implementar em Python e adicione ao código do item anterior a lógica abaixo:</p>
<pre><code class="language-py">    Insira os elementos em seus respectivos buckets.
</code></pre>
<details class="answer">
<summary>Gabarito</summary>
<pre><code class="language-py">def bucketSort(arr, noOfBuckets):
    max_ele = max(arr)
    min_ele = min(arr)
 
    rnge = (max_ele - min_ele) / noOfBuckets
 
    temp = []
 
    for i in range(noOfBuckets):
        temp.append([])

    for i in range(len(arr)):
        diff = (arr[i] - min_ele) / rnge -
              int((arr[i] - min_ele) / rnge)
 
        if(diff == 0 and arr[i] != min_ele):
            temp[int((arr[i] - min_ele) / rnge) - 1].append(arr[i])
 
        else:
            temp[int((arr[i] - min_ele) / rnge)].append(arr[i])
</code></pre>
</details>
</blockquote>
<blockquote class="question">
<p>Atividade</p>
<p>Agora vamos para o segundo loop. Tente implementar em Python e adicione ao código do item anterior a lógica abaixo:</p>
<pre><code class="language-py">	Ordenar cada bucket individualmente utilizando Insertion Sort.
</code></pre>
<details class="answer">
<summary>Gabarito</summary>
<pre><code class="language-py">def bucketSort(arr, noOfBuckets):
    max_ele = max(arr)
    min_ele = min(arr)
 
    rnge = (max_ele - min_ele) / noOfBuckets
 
    temp = []
 
    for i in range(noOfBuckets):
        temp.append([])
 
    for i in range(len(arr)):
        diff = (arr[i] - min_ele) / rnge -
              int((arr[i] - min_ele) / rnge)
 
        if(diff == 0 and arr[i] != min_ele):
            temp[int((arr[i] - min_ele) / rnge) - 1].append(arr[i])
 
        else:
            temp[int((arr[i] - min_ele) / rnge)].append(arr[i])
 
    for i in range(len(temp)):
        if len(temp[i]) != 0:
            temp[i].sort()
</code></pre>
</details>
</blockquote>
<blockquote class="question">
<p>Atividade</p>
<p>Agora vamos para o segundo loop. Tente implementar em Python e adicione ao código do item anterior a lógica abaixo:</p>
<pre><code class="language-py">	Juntar todos os buckets ordenados em um único vetor.
</code></pre>
<details class="answer">
<summary>Gabarito</summary>
<pre><code class="language-py">def bucketSort(arr, noOfBuckets):
    max_ele = max(arr)
    min_ele = min(arr)

    rnge = (max_ele - min_ele) / noOfBuckets
 
    temp = []

    for i in range(noOfBuckets):
        temp.append([])
 

    for i in range(len(arr)):
        diff = (arr[i] - min_ele) / rnge -
              int((arr[i] - min_ele) / rnge)
 

        if(diff == 0 and arr[i] != min_ele):
            temp[int((arr[i] - min_ele) / rnge) - 1].append(arr[i])
 
        else:
            temp[int((arr[i] - min_ele) / rnge)].append(arr[i])
 

    for i in range(len(temp)):
        if len(temp[i]) != 0:
            temp[i].sort()
 

    k = 0
    for lst in temp:
        if lst:
            for i in lst:
                arr[k] = i
                k = k+1
</code></pre>
</details>
</blockquote>
<p>De modo análogo, o <strong>bucket sort</strong>, ou bin sort, é um algoritmo de ordenação que funciona dividindo um vetor em um <strong>número finito de recipientes</strong>. Cada recipiente é então ordenado individualmente, seja usando um algoritmo de ordenação diferente, ou usando o algoritmo bucket sort recursivamente. Abaixo está um exemplo do Bucket Sort sendo aplicado.</p>
<div class="animation"><img class="frame" src="img/Slide/Slide0.png" alt="1"><img class="frame" src="img/Slide/Slide01.PNG" alt="2"><img class="frame" src="img/Slide/Slide02.PNG" alt="3"><img class="frame" src="img/Slide/Slide03.PNG" alt="4"><img class="frame" src="img/Slide/Slide04.PNG" alt="5"><img class="frame" src="img/Slide/Slide05.PNG" alt="6"><img class="frame" src="img/Slide/Slide06.PNG" alt="7"><img class="frame" src="img/Slide/Slide07.PNG" alt="8"><img class="frame" src="img/Slide/Slide08.PNG" alt="9"><img class="frame" src="img/Slide/Slide09.PNG" alt="10"><img class="frame" src="img/Slide/Slide10.PNG" alt="11"><img class="frame" src="img/Slide/Slide11.PNG" alt="12"><img class="frame" src="img/Slide/Slide12.PNG" alt="13"><img class="frame" src="img/Slide/Slide13.PNG" alt="14"><img class="frame" src="img/Slide/Slide14.PNG" alt="15"><img class="frame" src="img/Slide/Slide15.png" alt="16"><img class="frame" src="img/Slide/Slide16.PNG" alt="17"><img class="frame" src="img/Slide/Slide17.PNG" alt="18"><img class="frame" src="img/Slide/Slide18.png" alt="19"><img class="frame" src="img/Slide/Slide19.PNG" alt="20"><img class="frame" src="img/Slide/Slide20.png" alt="21"><img class="frame" src="img/Slide/Slide21.PNG" alt="22"><img class="frame" src="img/Slide/Slide22.PNG" alt="23"><img class="frame" src="img/Slide/Slide23.PNG" alt="24"><img class="frame" src="img/Slide/Slide24.PNG" alt="25"><img class="frame" src="img/Slide/Slide25.PNG" alt="26"><img class="frame" src="img/Slide/Slide26.PNG" alt="27"><img class="frame" src="img/Slide/Slide27.PNG" alt="28"><img class="frame" src="img/Slide/Slide28.PNG" alt="29"><img class="frame" src="img/Slide/Slide29.PNG" alt="30"></div>
<p>É muito comum o algoritmo utilizado nos recipientes do Bucket Sort ser o <strong>Insertion Sort</strong>.</p>
<blockquote class="question">
<p>Checkpoint</p>
<p>Para compreendermos melhor o funcionamento do Bucket Sort, vamos separar o vetor \([ 12, 30, 8, 22, 5, 7, 15, 27, 20, 9, 16 ]\) em seus respectivos recipientes (assim como foi feito no exemplo acima).</p>
<p><em>Pense nos intervalos para dividir os números igualmente entre os buckets</em></p>
<details class="answer">
<summary>Gabarito</summary>
<figure class="img"><img src="img/ex1.png" alt=""></figure>
</details>
</blockquote>
<h2>Complexidade e casos de uso</h2>
<p>Em se tratando de complexidade, você deve ter imaginado que o modo como os algarismos são distribuídos dentro do vetor ordenado pelo Bucket Sort influencia o tempo de ordenação.</p>
<blockquote class="question">
<p>Atividade</p>
<p>Considerando a implementação do Bucket Sort acima, qual você imagina que seria o pior caso de ordenação por Bucket Sort?</p>
<details class="answer">
<summary>Dica</summary>
<p>Imagine a ordenação do seguinte vetor nos buckets do exemplo anterior:</p>
<p>[1 2 3 4 5 6 7 8 9]</p>
</details>
<details class="answer">
<summary>Gabarito</summary>
<p>O pior caso de ordenação seria justamente o do vetor [1 2 3 4 5 6 7 8 9] nos buckets do exemplo, já que todos os elementos vão cair no mesmo bucket, tornando inútil a divisão do vetor em buckets.</p>
</details>
</blockquote>
<p>Desse modo, pode-se considerar que, no <strong>pior caso</strong>, se todos os elementos caírem no mesmo bucket, a <strong>complexidade</strong> será <strong>igual à</strong> própria <strong>complexidade do algoritmo de ordenação</strong>.</p>
<blockquote class="question">
<p>Atividade</p>
<p>E qual você imagina que seria o melhor caso de ordenação por Bucket Sort?</p>
<details class="answer">
<summary>Gabarito</summary>
<p>O melhor caso de ordenação ocorre quando os elementos do vetor são distribuídos homogeneamente entre os buckets.</p>
</details>
</blockquote>
<p>Agora considerando o <strong>melhor caso</strong>, é um pouco mais complicado de analisar a complexidade. A fim de exemplo, vamos imaginar que o algoritmo de ordenação é o <strong>Insertion Sort</strong>, que é adequado para o Bucket Sort, pois ele é bom para vetores pequenos e espera-se que os buckets contenham vetores pequenos.</p>
<p>Considerando que a complexidade do Insertion Sort no pior caso é \(O(n^2)\) e que, se
a distribuição é boa e você tem \(k\) buckets, o tamanho de cada bucket é \(n/k\) e a complexidade será igual a \(O((n/k)^2)\), isto é, \(O(n^2/k^2)\).
Como isso será feito para os \(k\) buckets, a complexidade total dessa fase será igual a \(O((n^2/k^2)·k)\), isto é, <strong>\(O(n^2/k)\)</strong>.</p>
<blockquote class="question">
<p>Atividade</p>
<p>Considerando essa complexidade, em que tipos de vetor você acredita que o Bucket Sort operaria de forma mais rápida?</p>
<details class="answer">
<summary>Gabarito</summary>
<p>O Bucket Sort melhor performa, em termos de tempo, em vetores grandes, quanto maior o valor de \(k\).</p>
</details>
</blockquote>
<p>Isso significa que, se o seu \(k\) não foi muito pequeno, você consegue fazer com que a complexidade fique melhor do que \(O(n^2)\). Em particular, se \(k\) for proporcional a \(n^2\), a complexidade se tornará linear.</p>
<p>Desse modo, muitas vezes, o Bucket Sort é utilizado como algoritmo de ordenação externo, especialmente se você precisa ordenar um <strong>vetor que é tão grande que não cabe na sua memória</strong>.</p>


            </main>
            <footer>
                <a href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">
                    <img alt="CC BY-SA 4.0" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" title="Creative Commons Attribution-ShareAlike 4.0 International License"/>
                </a>
                © 2022 Marcelo Hashimoto
            </footer>
        </div>
    </body>
</html>
